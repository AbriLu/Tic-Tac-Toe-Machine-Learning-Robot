/*  Testing code for Mover database on SD card*/#include <SPI.h>#include <SD.h>#include <LiquidCrystal.h>// initialize the library by associating any needed LCD interface pin// with the arduino pin number it is connected toconst int rs = 4, en = 8, d4 = 9, d5 = 10, d6 = 11, d7 = 12;LiquidCrystal lcd(rs, en, d4, d5, d6, d7);File dataFile;int Board_id;int best_move;int found_in_database;int new_id;int sym_ids[9];             //array with board id symetriesint moves_record[4][3];     // record of moves played board id and moveint default_probability = 4;  // default proability to assign for new database entriesint game_result;int symetry_index;int i;int mytoken = 1;        // Choose to play token "1"int opponent_token;const int ChipSelect = 53;String pos1, pos2, pos3, pos4, pos5, pos6, pos7, pos8, pos9;  //declare position strings for lcdString line1, line2, line3, line4;const unsigned int MAX_MESSAGE_LENGTH = 6;int opponent_move_position;int next_play;struct Board {    int Boardid;    int P1;    int P2;    int P3;    int P4;    int P5;    int P6;    int P7;    int P8;    int P9;};struct Board myBoard;void setup() {  Serial.begin(9600);  Serial.print("Initializing SD card...");  pinMode(53, OUTPUT);    if (!SD.begin(ChipSelect)) {    Serial.println("initialization failed!");    while (1);  }  Serial.println("initialization done.");    dataFile = SD.open("data.dat", FILE_WRITE);  Serial.println("File opened");  delay(100);  dataFile.close();  Serial.println("File closed");     // set up the LCD's number of columns and rows:  lcd.begin(20, 4);  // Print a message to the LCD.    lcd.setCursor(3,3);  lcd.print("hello, world!");            // initialise the moves recorded array  for (int i = 1; i<4;i++){    for(int j = 1; j<3; j++){      moves_record[i][j] = 0;    }  }   display_moves();          if(mytoken == 1){     opponent_token = 0;   }      if(mytoken == 0){     opponent_token = 1;   }      game_result = 3;   next_play = 0;  Board_id = 19682;}void loop() {      // initialise the board      lcd_display_board(Board_id);         if(next_play == 1){   next_play=0; } else {   next_play = 1; }    game_result = game_outcome(Board_id);  learner(game_result);  switch (game_result) {        case 0:          Serial.print("0 has won !!!");          lcd.setCursor(10,2);          lcd.print("0 has won !");          reset_game();          break;        case 1:          Serial.println("1 has won !!!");          lcd.setCursor(10,2);          lcd.print("1 has won !");          delay(3000);          reset_game();        break;        case 2:          Serial.println("Game draw !!!");          lcd.setCursor(10,2);          lcd.println(" Draw !");          delay(3000);          reset_game();        break;        case 3:          Serial.println("Game continue");          lcd.setCursor(10,2);          lcd.print("Play");                  if(next_play == 0){            opponent_move_position = get_opponent_move();            Board_id = new_board_id(Board_id,opponent_move_position, opponent_token);  // compute board id of oppnent position           }          if (next_play == 1){            Board_id = player(Board_id);          }        break;        default:          Serial.println("No outcome?");          reset_game();        break;      }    lcd_display_board(Board_id);}            // this function gets the best move from the databaseint get_move(int search_id){      dataFile = SD.open("data.dat", FILE_READ);      Serial.println("File opened");      struct Board myBoard;      bool board_found = false;      int move = -1;      int Probability[10];      int p_low[10];      int p_high[10];      int pick_move;                        while (dataFile.available() && board_found==false) {        dataFile.read((uint8_t *)&myBoard, sizeof(myBoard));                        if(myBoard.Boardid == search_id){          board_found = true;          Board_id       = myBoard.Boardid;          Probability[1] = myBoard.P1;          Probability[2] = myBoard.P2;          Probability[3] = myBoard.P3;          Probability[4] = myBoard.P4;          Probability[5] = myBoard.P5;          Probability[6] = myBoard.P6;          Probability[7] = myBoard.P7;          Probability[8] = myBoard.P8;          Probability[9] = myBoard.P9;          Serial.println("Board in database");          Serial.println(Board_id);           // Print probabilities of board id          for (int i=1; i < 10;i++){            Serial.print(Probability[i]);            Serial.print(" ");            delay(50);          }        }      }                if (board_found == true){                                // compute the proability bins          p_low[1] = 0;                           //get low value for position 1          p_high[1] = p_low[1] + Probability[1];  // get high value for position 1          Serial.println("The move bins are:");          Serial.print("Low end = ");          Serial.print(p_low[1]);          Serial.print(" High end = ");          Serial.println(p_high[1]);          for (int i = 2; i < 10; i++) {            p_low[i] = p_high[i - 1];               // get low value for position 2 - 9            p_high[i] = p_low[i] + Probability[i];  // get high value for position 2 -9            Serial.print("Low end = ");            Serial.print(p_low[i]);            Serial.print(" High end = ");            Serial.println(p_high[i]);          }          // draw random numnber          pick_move = random(0, p_high[9]);          // draw the random number          Serial.print("the random number is = ");          Serial.println(pick_move);          // find the move          for (int i = 1; i < 10; i++) {                  // determine the bin in which the random number i            if ((pick_move >= p_low[i]) && (pick_move < p_high[i]) ) {              move = i;                            // suggested move              Serial.print("The best move is = ");              Serial.println(move);            }          }                    }         dataFile.close();         Serial.println("File closed");          return move;            }  // this function compute the new board id for the suggested best moveint new_board_id(int board_id,int move, int token){ int position[10];  int residual; int new_board_id;  Serial.print("old board id = "); Serial.println(board_id); Serial.print("suggested move = "); Serial.println(move);   // extract postions from board id  position[1] = board_id / 6561;  residual = (board_id % 6561);  position[2] = residual / 2187;  residual = residual % 2187;  position[3] = residual / 729;  residual = residual % 729;  position[4] = residual / 243;  residual = residual % 243;  position[5] = residual / 81;  residual = residual % 81;  position[6] = residual / 27;  residual = residual % 27;  position[7] = residual / 9;  residual = residual % 9;  position[8] = residual / 3;  residual = residual % 3;  position[9] = residual / 1;  residual = residual % 1;    // replace best move  position[move] = token;                  // compute new board id    new_board_id = position[1] * 6561;  new_board_id = position[2] * 2187 + new_board_id;  new_board_id = position[3] * 729 + new_board_id;  new_board_id = position[4] * 243 + new_board_id;  new_board_id = position[5] * 81 + new_board_id;  new_board_id = position[6] * 27 + new_board_id;  new_board_id = position[7] * 9 + new_board_id;  new_board_id = position[8] * 3 + new_board_id;  new_board_id = position[9] * 1 + new_board_id;    Serial.print("new board id = ");  Serial.println(new_board_id);    return new_board_id;  }// This function converts the board id to a board layoutvoid convert_id_to_board(int board_id){  // extract postions from board id  int residual;  myBoard.Boardid = board_id;  myBoard.P1 = board_id / 6561;  residual = (board_id % 6561);  myBoard.P2 = residual / 2187;  residual = residual % 2187;  myBoard.P3 = residual / 729;  residual = residual % 729;  myBoard.P4 = residual / 243;  residual = residual % 243;  myBoard.P5 = residual / 81;  residual = residual % 81;  myBoard.P6 = residual / 27;  residual = residual % 27;  myBoard.P7 = residual / 9;  residual = residual % 9;  myBoard.P8 = residual / 3;  residual = residual % 3;  myBoard.P9 = residual / 1;  residual = residual % 1;}// This function covert a board layout to a board idint convert_board_to_id(){  int new_board_id;  new_board_id = myBoard.P1 * 6561;  new_board_id = myBoard.P2 * 2187 + new_board_id;  new_board_id = myBoard.P3 * 729 + new_board_id;  new_board_id = myBoard.P4 * 243 + new_board_id;  new_board_id = myBoard.P5 * 81 + new_board_id;  new_board_id = myBoard.P6 * 27 + new_board_id;  new_board_id = myBoard.P7 * 9 + new_board_id;  new_board_id = myBoard.P8 * 3 + new_board_id;  new_board_id = myBoard.P9 * 1 + new_board_id;    return new_board_id;  }//This function print to serial the board layoutvoid print_board(){  Serial.println(myBoard.Boardid);  Serial.print(myBoard.P1);  Serial.print(myBoard.P2);  Serial.print(myBoard.P3);  Serial.print(myBoard.P4);  Serial.print(myBoard.P5);  Serial.print(myBoard.P6);  Serial.print(myBoard.P7);  Serial.print(myBoard.P8);  Serial.println(myBoard.P9);}// This function compute an array of all board id symetriesvoid create_symetries(int board_id){  int temp[10];  sym_ids[1] = board_id;      // original id  convert_id_to_board(board_id);      // id converted to board  temp[1] = myBoard.P1;  temp[2] = myBoard.P2;  temp[3] = myBoard.P3;  temp[4] = myBoard.P4;  temp[5] = myBoard.P5;  temp[6] = myBoard.P6;  temp[7] = myBoard.P7;  temp[8] = myBoard.P8;  temp[9] = myBoard.P9;      // rotation 1    myBoard.P1 = temp[7];  myBoard.P2 = temp[4];  myBoard.P3 = temp[1];  myBoard.P4 = temp[8];  myBoard.P5 = temp[5];  myBoard.P6 = temp[2];  myBoard.P7 = temp[9];  myBoard.P8 = temp[6];  myBoard.P9 = temp[3];  sym_ids[2] = convert_board_to_id();    // rotation 2  myBoard.P1 = temp[9];  myBoard.P2 = temp[8];  myBoard.P3 = temp[7];  myBoard.P4 = temp[6];  myBoard.P5 = temp[5];  myBoard.P6 = temp[4];  myBoard.P7 = temp[3];  myBoard.P8 = temp[2];  myBoard.P9 = temp[1];  sym_ids[3] = convert_board_to_id();    // rotation 3  myBoard.P1 = temp[3];  myBoard.P2 = temp[6];  myBoard.P3 = temp[9];  myBoard.P4 = temp[2];  myBoard.P5 = temp[5];  myBoard.P6 = temp[8];  myBoard.P7 = temp[1];  myBoard.P8 = temp[4];  myBoard.P9 = temp[7];  sym_ids[4] = convert_board_to_id();    // Top Bottom  myBoard.P1 = temp[7];  myBoard.P2 = temp[8];  myBoard.P3 = temp[9];  myBoard.P4 = temp[4];  myBoard.P5 = temp[5];  myBoard.P6 = temp[6];  myBoard.P7 = temp[1];  myBoard.P8 = temp[2];  myBoard.P9 = temp[3];  sym_ids[5] = convert_board_to_id();    // Left Right  myBoard.P1 = temp[3];  myBoard.P2 = temp[2];  myBoard.P3 = temp[1];  myBoard.P4 = temp[6];  myBoard.P5 = temp[5];  myBoard.P6 = temp[4];  myBoard.P7 = temp[9];  myBoard.P8 = temp[8];  myBoard.P9 = temp[7];  sym_ids[6] = convert_board_to_id();    // minus 45  myBoard.P1 = temp[1];  myBoard.P2 = temp[4];  myBoard.P3 = temp[7];  myBoard.P4 = temp[2];  myBoard.P5 = temp[5];  myBoard.P6 = temp[8];  myBoard.P7 = temp[3];  myBoard.P8 = temp[6];  myBoard.P9 = temp[9];  sym_ids[7] = convert_board_to_id();    // plus 45  myBoard.P1 = temp[9];  myBoard.P2 = temp[6];  myBoard.P3 = temp[3];  myBoard.P4 = temp[8];  myBoard.P5 = temp[5];  myBoard.P6 = temp[2];  myBoard.P7 = temp[7];  myBoard.P8 = temp[4];  myBoard.P9 = temp[1];  sym_ids[8] = convert_board_to_id();    for (int i=1;i<9;i++){    Serial.println("The board symetries are:");    Serial.println(sym_ids[i]);  }  }// This function compute the board id from the reverse symetryint id_reverse_symetry(int board_id, int symetry_index){    int temp[8];    int new_board_id;    convert_id_to_board(board_id);      // id converted to board    temp[1] = myBoard.P1;    temp[2] = myBoard.P2;    temp[3] = myBoard.P3;    temp[4] = myBoard.P4;    temp[5] = myBoard.P5;    temp[6] = myBoard.P6;    temp[7] = myBoard.P7;    temp[8] = myBoard.P8;    temp[9] = myBoard.P9;        switch (symetry_index) {  case 1:    // statements    myBoard.P1 = temp[1];    myBoard.P2 = temp[2];    myBoard.P3 = temp[3];    myBoard.P4 = temp[4];    myBoard.P5 = temp[5];    myBoard.P6 = temp[6];    myBoard.P7 = temp[7];    myBoard.P8 = temp[8];    myBoard.P9 = temp[9];        break;  case 2:    // rotation 1 reverse    myBoard.P7 = temp[1];    myBoard.P4 = temp[2];    myBoard.P1 = temp[3];    myBoard.P8 = temp[4];    myBoard.P5 = temp[5];    myBoard.P2 = temp[6];    myBoard.P9 = temp[7];    myBoard.P6 = temp[8];    myBoard.P3 = temp[9];    break;        case 3:    // rotation 2 reverse    myBoard.P9 = temp[1];    myBoard.P8 = temp[2];    myBoard.P7 = temp[3];    myBoard.P6 = temp[4];    myBoard.P5 = temp[5];    myBoard.P4 = temp[6];    myBoard.P3 = temp[7];    myBoard.P2 = temp[8];    myBoard.P1 = temp[9];    break;        case 4:    // rotation 3 reverse    myBoard.P3 = temp[1];    myBoard.P6 = temp[2];    myBoard.P9 = temp[3];    myBoard.P2 = temp[4];    myBoard.P5 = temp[5];    myBoard.P8 = temp[6];    myBoard.P1 = temp[7];    myBoard.P4 = temp[8];    myBoard.P7 = temp[9];    break;        case 5:    // top bottom reverse    myBoard.P7 = temp[1];    myBoard.P8 = temp[2];    myBoard.P9 = temp[3];    myBoard.P4 = temp[4];    myBoard.P5 = temp[5];    myBoard.P6 = temp[6];    myBoard.P1 = temp[7];    myBoard.P2 = temp[8];    myBoard.P3 = temp[9];    break;        case 6:    // Left Right reverse    myBoard.P3 = temp[1];    myBoard.P2 = temp[2];    myBoard.P1 = temp[3];    myBoard.P6 = temp[4];    myBoard.P5 = temp[5];    myBoard.P4 = temp[6];    myBoard.P9 = temp[7];    myBoard.P8 = temp[8];    myBoard.P7 = temp[9];    break;        case 7:    // minus 45 reverse    myBoard.P1 = temp[1];    myBoard.P4 = temp[2];    myBoard.P7 = temp[3];    myBoard.P2 = temp[4];    myBoard.P5 = temp[5];    myBoard.P8 = temp[6];    myBoard.P3 = temp[7];    myBoard.P6 = temp[8];    myBoard.P9 = temp[9];    break;        case 8:    // plus 45 reverse    myBoard.P9 = temp[1];    myBoard.P6 = temp[2];    myBoard.P3 = temp[3];    myBoard.P8 = temp[4];    myBoard.P5 = temp[5];    myBoard.P2 = temp[6];    myBoard.P7 = temp[7];    myBoard.P4 = temp[8];    myBoard.P1 = temp[9];    break;      default:    // statements    Serial.println("Not one ofthe reverse symetries");    break;  }    // compute new board id    new_board_id = convert_board_to_id();  return new_board_id;}// this function records the last 3 moves playedvoid record_move(int Board_id, int move){    moves_record[3][1] = moves_record[2][1];  moves_record[3][2] = moves_record[2][2];  moves_record[2][1] = moves_record[1][1];  moves_record[2][2] = moves_record[1][2];  moves_record[1][1] = Board_id;  moves_record[1][2] = move;  //Serial.println("Moves to record:");  display_moves();}// This function determines the game outcome win loose drawint game_outcome(int board_id){  int outcome = 2;    // 0 = 0 has won 1 = 1 has won, 2 = draw, 3 = play on  int temp[10];  int move_id;  int aa,bb,cc;    convert_id_to_board(board_id);       temp[1] = myBoard.P1;    temp[2] = myBoard.P2;     temp[3] = myBoard.P3;    temp[4] = myBoard.P4;    temp[5] = myBoard.P5;    temp[6] = myBoard.P6;    temp[7] = myBoard.P7;    temp[8] = myBoard.P8;    temp[9] = myBoard.P9;    // if there are any open places then it is not a draw  for(int i=1;i<10;i++){     if(temp[i]==2){       outcome = 3;           // if there are still an open space play continues     }   }      // Test for 0 or 1 to win    for (int i=0;i<2;i++){    if ((temp[1]==i)&&(temp[2]==i)&&(temp[3]==i)){      outcome = i;    }      if ((temp[4]==i)&&(temp[5]==i)&&(temp[6]==i)){      outcome = i;    }      if ((temp[7]==i)&&(temp[8]==i)&&(temp[9]==i)){     outcome = i;    }       if ((temp[1]==i)&&(temp[4]==i)&&(temp[7]==i)){      outcome = i;    }      if ((temp[2]==i)&&(temp[5]==i)&&(temp[8]==i)){      outcome = i;    }      if ((temp[3]==i)&&(temp[6]==i)&&(temp[9]==i)){      outcome = i;    }       if ((temp[1]==i)&&(temp[5]==i)&&(temp[9]==i)){      outcome = i;    }       if ((temp[3]==i)&&(temp[5]==i)&&(temp[7]==i)){      outcome = i;    }    }      return outcome;}// This function creates a database entry and assign default probabilitiesvoid add_to_database(int Board_id){  int temp[10];  convert_id_to_board(Board_id);      temp[1] = myBoard.P1;    temp[2] = myBoard.P2;    temp[3] = myBoard.P3;    temp[4] = myBoard.P4;    temp[5] = myBoard.P5;    temp[6] = myBoard.P6;    temp[7] = myBoard.P7;    temp[8] = myBoard.P8;    temp[9] = myBoard.P9;      for(int i=1;i<10;i++){        if(temp[i] == 2){        temp[i] = default_probability;      }      else {        temp[i] = 0;  // position can not be played      }        }    myBoard.Boardid = Board_id;  myBoard.P1 = temp[1];  myBoard.P2 = temp[2];  myBoard.P3 = temp[3];  myBoard.P4 = temp[4];  myBoard.P5 = temp[5];  myBoard.P6 = temp[6];  myBoard.P7 = temp[7];  myBoard.P8 = temp[8];  myBoard.P9 = temp[9];  // safe structure to file    dataFile = SD.open("data.dat", FILE_WRITE);  dataFile.write((const uint8_t *)&myBoard, sizeof(myBoard));    delay(500);    dataFile.close();    Serial.print("Database added : ");    print_board();    //Serial.println(Board_id);    Serial.println("File closed after adding");        delay(500);}// this function see if board is in database    int peek_database(int search_id){    dataFile = SD.open("data.dat", FILE_READ);    Serial.println("File opened");    struct Board myBoard;    bool board_found = false;    int in_database = -1;            while (dataFile.available() && board_found==false) {        dataFile.read((uint8_t *)&myBoard, sizeof(myBoard));                        if(myBoard.Boardid == search_id){          board_found = true;          in_database = 1;          Serial.println("Board in database");          Serial.println(Board_id);           // Print probabilities of board id          delay(50);          }        }              dataFile.close();         Serial.println("File closed");          return in_database;          }void display_moves(){  Serial.println("Moves recorded:");  Serial.print(moves_record[1][1]);  Serial.print(" ");  Serial.println(moves_record[1][2]);    Serial.print(moves_record[2][1]);  Serial.print(" ");  Serial.println(moves_record[2][2]);    Serial.print(moves_record[3][1]);  Serial.print(" ");  Serial.println(moves_record[3][2]);  }    void update_database(int search_id , int position, int probability){        Serial.println("In function Update datbase");    Serial.print("Looking for board id =");    Serial.print(search_id);    Serial.println(" position =");    Serial.print(position);    Serial.println(" probability =");    Serial.print(probability);            dataFile = SD.open("data.dat", O_RDWR);    Serial.println("File opened");    int minimum_probability = 3;        // minimum value for position probability    bool board_found = false;    int in_database = -1;    unsigned int file_pointer;    int temp[10];    int plek;            while (dataFile.available() && board_found==false) {        dataFile.read((uint8_t *)&myBoard, sizeof(myBoard));         if(myBoard.Boardid == search_id){          board_found = true;          in_database = 1;          file_pointer = dataFile.position();          file_pointer = file_pointer - sizeof(myBoard);                    Serial.print("file pointer for entry is = ");          Serial.println(file_pointer);          print_board();        }                }            if(board_found == true){                      temp[1] = myBoard.P1;            temp[2] = myBoard.P2;            temp[3] = myBoard.P3;            temp[4] = myBoard.P4;            temp[5] = myBoard.P5;            temp[6] = myBoard.P6;            temp[7] = myBoard.P7;            temp[8] = myBoard.P8;            temp[9] = myBoard.P9;                      temp[position] = temp[position] + probability;    // change the probability                        if(temp[position] < minimum_probability) {                           // limit minimum probability value              temp[position] = minimum_probability;            }                                  myBoard.P1 = temp[1];            myBoard.P2 = temp[2];            myBoard.P3 = temp[3];            myBoard.P4 = temp[4];            myBoard.P5 = temp[5];            myBoard.P6 = temp[6];            myBoard.P7 = temp[7];            myBoard.P8 = temp[8];            myBoard.P9 = temp[9];                      Serial.println("The updated board to store is = ");            print_board();                      dataFile.seek(file_pointer);      // position pointer                       dataFile.write((uint8_t *)&myBoard, sizeof(myBoard));            delay(500);                      plek = dataFile.position();                      Serial.println("pointer after written new entry =");            Serial.println(plek);                      dataFile.seek(file_pointer);      // position pointer                       dataFile.read((uint8_t *)&myBoard, sizeof(myBoard));                      Serial.println("read from file pointerposition");                      print_board();                      delay(50);          }                         dataFile.close();          Serial.println("File closed");                   }void show_database(){  Serial.println("Showing database");  dataFile = SD.open("data.dat", O_RDWR);      Serial.println("File opened");            while (dataFile.available() ) {        dataFile.read((uint8_t *)&myBoard, sizeof(myBoard));                print_board();      }            dataFile.close();        Serial.println("File closed");  }// this function teaches the databbase as result of game outcomevoid learner(int outcome){  int aa,bb,cc;    Serial.print("In learner. outcome = ");  Serial.println(outcome);  display_moves();      if(outcome == mytoken){           // I have won  reward the last three moves          Serial.println(" I have won ");      Serial.print(F("database to be updated with last move:"));      Serial.println(moves_record[1][1] , moves_record[1][2]);       aa = moves_record[1][1];      bb = moves_record[1][2];            update_database(aa  , bb , 3) ; //              Serial.print(F("database to be updated with second last move:"));      Serial.println(moves_record[2][1] , moves_record[2][2]);      aa = moves_record[2][1];      bb = moves_record[2][2];            update_database(aa  , bb , 2) ; //            Serial.print(F("database to be updated with third last move:"));      Serial.println(moves_record[3][1] , moves_record[3][2]);      aa = moves_record[3][1];      bb = moves_record[3][2];            update_database(aa  , bb , 1) ;          }      if(outcome == 2 ){                // outcome is a draw            Serial.println(" Game draw ");      Serial.print(F("database to be updated with last move:"));      Serial.println(moves_record[1][1] , moves_record[1][2]);      aa = moves_record[1][1];      bb = moves_record[1][2];      update_database(aa  , bb , 1) ; //              Serial.print(F("database to be updated with second last move:"));      Serial.println(moves_record[2][1] , moves_record[2][2]);      aa = moves_record[2][1];      bb = moves_record[2][2];      update_database(aa  , bb , 1) ; //            Serial.print(F("database to be updated with third last move:"));      Serial.println(moves_record[3][1] , moves_record[3][2]);      aa = moves_record[3][1];      bb = moves_record[3][2];      update_database(aa  , bb , 1) ; //    }      if( ( (outcome == 1) && (mytoken == 0 ) ) || (  (outcome == 0) && (mytoken == 1 )))  {                // I lose penalise      Serial.println(" I have Lost ");      Serial.print(F("database to be updated with last move:"));      Serial.println(moves_record[1][1] , moves_record[1][2]);      aa = moves_record[1][1];      bb = moves_record[1][2];      update_database(aa  , bb , -3) ; //              Serial.print(F("database to be updated with second last move:"));      Serial.println(moves_record[2][1] , moves_record[2][2]);      aa = moves_record[2][1];      bb = moves_record[2][2];      update_database(aa  , bb , -2) ; //            Serial.print(F("database to be updated with third last move:"));      Serial.println(moves_record[3][1] , moves_record[3][2]);      aa = moves_record[3][1];      bb = moves_record[3][2];      update_database(aa  , bb , -1) ; //    }        if ( (outcome == 0) || (outcome == 1) || (outcome == 2 )   ){         // if game completed clear move record     // clear moves record     Serial.println(" Gamne over ");     Serial.println("Clear move record");    display_moves();    // clear moves recorded array    for (int i = 1; i<4;i++){      for(int j = 1; j<3; j++){        moves_record[i][j] = 0;      }    }        Serial.println("Moves record cleared");    display_moves();          }   Serial.println("Leaving learner");  }// This function plays one move sequenceint player(int Board_id){          lcd_display_board(Board_id);        // create symtries array from board id    create_symetries(Board_id);     // create the array of all equivalent boards        // search database for any one of the symetry board ids        found_in_database = 0;    best_move = 0;    i = 1;    symetry_index = 0;    game_result = -1;        while((i < 9) && (found_in_database == 0)) {          Serial.print("Looking for i =");      Serial.println(i);      Serial.print("Board id = ");      Serial.println(sym_ids[i]);            best_move = peek_database(sym_ids[i] );       // check if board is in database      if(best_move == 1){        found_in_database = 1;        symetry_index = i;        Serial.println("Found in database");        Serial.println(sym_ids[i]);        Serial.print("Symetry index = ");        Serial.println(symetry_index);      }      i++;          }        // if not in database add to database        if(found_in_database == 0){           // not in database to be created      Serial.println("Board to be added to database");            add_to_database(sym_ids[1]);        // add the entry to the database      found_in_database = 1;      symetry_index = 1;      }            // get the best move from database for symetry id     best_move = get_move(sym_ids[symetry_index]);         // get the best move for the board    if(best_move== -1){      Serial.println("Problem no move in database");      //while(1);    }            // record the suggested move    record_move(sym_ids[symetry_index], best_move);             // record the move              // compute the new board id from the suggested move    new_id = new_board_id( sym_ids[symetry_index] ,best_move, mytoken); //compute the board id of the suggested move    Serial.print("The new board id is =");    Serial.println(new_id);                 // compute the board id of the reverse symetry board    new_id = id_reverse_symetry(new_id, symetry_index);           // reverse symetry the board    Serial.print("The reverse symetry id is =");    Serial.println(new_id);    print_board();        Serial.print("The board to play is = ");    Serial.println(new_id);    lcd_display_board(new_id);          //show_database();                  return new_id;      }// This function display the board on the lcd displayvoid lcd_display_board(int Board_id){    convert_id_to_board(Board_id);  print_board();      if(myBoard.P1 == 2){    pos1 = " ";  }  else  {    pos1 = String(myBoard.P1);  }    if(myBoard.P2 == 2){    pos2 = " ";  }  else  {    pos2 = String(myBoard.P2);  }    if(myBoard.P3 == 2){    pos3 = " ";  }  else  {    pos3 = String(myBoard.P3);  }    if(myBoard.P4 == 2){    pos4 = " ";  }  else  {    pos4 = String(myBoard.P4);  }    if(myBoard.P5 == 2){    pos5 = " ";  }  else  {    pos5 = String(myBoard.P5);  }    if(myBoard.P6 == 2){    pos6 = " ";  }  else  {    pos6 = String(myBoard.P6);  }    if(myBoard.P7 == 2){    pos7 = " ";  }  else  {    pos7 = String(myBoard.P7);  }    if(myBoard.P8 == 2){    pos8 = " ";  }  else  {    pos8 = String(myBoard.P8);  }    if(myBoard.P9 == 2){    pos9 = " ";  }  else  {    pos9 = String(myBoard.P9);  }    line1 = pos1 + "|" + pos2 + "|" + pos3;  line2 = pos4 + "|" + pos5 + "|" + pos6;  line3 = pos7 + "|" + pos8 + "|" + pos9;  line4 = String(myBoard.Boardid);// column then row  lcd.clear();  lcd.setCursor(0,0);  lcd.print(line1);  lcd.setCursor(0,1);  lcd.print(line2);  lcd.setCursor(0,2);  lcd.print(line3);  lcd.setCursor(0,3);  lcd.print(line4);              }  // this function get opponent move position from serialint get_opponent_move(){    bool position_received = false;  opponent_move_position = 0;  static char message[MAX_MESSAGE_LENGTH];  static unsigned int message_pos = 0;  Serial.println(F("wainting for opponent move"));    while (position_received == false ){      if  (Serial.available() > 0)  {      //Read the next available byte in the serial receive buffer      char inByte = Serial.read();      //Message coming in (check not terminating character) and guard for over message size            if ( inByte != '\n' )       {        //Add the incoming byte to our message        message[message_pos] = inByte;        message_pos++;      }      //Full message received...      else      {       //Add null character to string       message[message_pos] = '\0';        //Print the message (or do other things)        Serial.println(message);        position_received = true;        opponent_move_position = atoi(message);        //Reset for the next message         message_pos = 0;      }        }            }       return opponent_move_position;      }   void reset_game(){  Board_id = 19682;  if(next_play == 1){   next_play=0; } else {   next_play = 1; }lcd.clear();  }